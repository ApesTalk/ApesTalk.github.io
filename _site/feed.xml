<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ApesTalk</title>
    <description>鸟活着时，吃蚂蚁，鸟死后，蚂蚁吃鸟。一棵树可以制成一百万根火柴，烧光一百万棵树只需一根火柴。活着，低调做人。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 20 Mar 2019 09:35:14 +0800</pubDate>
    <lastBuildDate>Wed, 20 Mar 2019 09:35:14 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Anyway，我被UIWindow打脸了</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/window.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需求好轮回，bug绕过谁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;近日捕获一bug，经排查定位后发现，该bug属于通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].keyWindow.rootViewController&lt;/code&gt;方法拿到了错误的控制器，导致后面执行的代码异常。下面请听我细细为你讲述该bug的前世今生。&lt;/p&gt;

&lt;p&gt;因为是线上bug，奔溃在了广告业务加载完了之后，考虑到会影响大量用户，内心甚是恐慌。因为奔溃的地方是最近才改的代码，所以起初我一直在最近的两个业务需求里排查问题，因为最近另外一个需求也添加了一个window。事实上，我被狠狠的打脸了，脸好疼。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/ohshit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过测试和分析，最近新增的这个window并不会导致这个问题。确定启动的时候也没有类似UIAlertView这种弹窗会弹出来，那为什么通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].keyWindow&lt;/code&gt;拿到了错误的window呢？不找到问题点实在是难以饶恕自己啊！&lt;/p&gt;

&lt;p&gt;到后来，再看线上更新最近这个版本的用户很多，但是这个崩溃只有一例，再加上确认不是因为启动时和其他业务互相影响导致的启动就崩的严重bug。我的内心稍微平复了一些，没那么慌了，能够静下心来理性地分析问题了。&lt;/p&gt;

&lt;p&gt;回归到问题源头，首先，我们知道当我们调用UIWindow的&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;时，系统会调用它的&lt;code class=&quot;highlighter-rouge&quot;&gt;hidden = NO&lt;/code&gt;让它显示出来，另外会帮我们把它加入&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].windows&lt;/code&gt;数组中。当我们调用&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].keyWindow&lt;/code&gt;时，系统给我们返回一个最近调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;方法的window。一般正常情况下我们一个APP只有一个window，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].keyWindow&lt;/code&gt;拿我们的主window是没有问题的，只有当我们程序中出现多个window的时候才可能会出现问题。那么第二个问题来了，什么时候回出现多个window呢，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].windows&lt;/code&gt;数组长度不为1，那必须是显式或隐式地调用了window的&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;方法才会出现这种情况。&lt;/p&gt;

&lt;p&gt;然后，我在项目中搜&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;方法，找到了一个很早之前的业务需求处用到了一个window并调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;方法，当时是为了解决其他问题。实在是没有想到会是跟这里的业务相互影响了。一把辛酸泪啊，突然想说一句“不是你的代码没有bug，而是你的bug需要点时间。”&lt;/p&gt;

&lt;p&gt;另外需要注意的是，项目中有历史遗留的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIActionSheet&lt;/code&gt;的，要尽快把它们改掉了，因为随着业务的不断增长，在有这些弹窗的时候如果去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].keyWindow&lt;/code&gt;拿到的会是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;_UIAlertControllerShimPresenterWindow&lt;/code&gt;，它的rootViewController是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationRotationFollowingController&lt;/code&gt;。很明显，在它们弹出来的时候，系统会新建一个UIWindow，并且为了在不管当前视图层级结构是怎样的，都将弹窗置为最上层让用户能看到，所以不得不调用了window的&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;方法。这是一个隐患，我猜测苹果新推出&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertController&lt;/code&gt;来替代&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIActionSheet&lt;/code&gt;有这方面的考量。&lt;/p&gt;

&lt;p&gt;所以，这里有三个建议：&lt;/p&gt;

&lt;p&gt;1、建议是尽快把项目中的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIActionSheet&lt;/code&gt;换成&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertController&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;2、在拿主window的时候通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication].delegate.window&lt;/code&gt;方式拿。&lt;/p&gt;

&lt;p&gt;3、在使用除主UIWindow外的其他window时，如果你只是想把它展示出来，直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;window.hidden = NO&lt;/code&gt;即可，如果没有强制要将该window置为最上层，就不要去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;makeKeyAndVisible&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这次被UIWinow打脸呢，有点意外，幸好没有酿成重大必陷bug。这件事又给我了一个大教训，那就是遇事不要慌张，不要一上来就凭借自己的经验随便下结论，一定要静下心来理性地思考，先仔细分析bug，先摸清bug的来龙去脉，再顺藤摸瓜就很简单了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;
</description>
        <pubDate>Mon, 28 Jan 2019 03:40:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/Anyway-%E6%88%91%E8%A2%ABUIWindow%E6%89%93%E8%84%B8%E4%BA%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/Anyway-%E6%88%91%E8%A2%ABUIWindow%E6%89%93%E8%84%B8%E4%BA%86/</guid>
        
        <category>UIWindow</category>
        
        <category>makeKeyAndVisible</category>
        
        <category>hidden=NO</category>
        
        
      </item>
    
      <item>
        <title>Shell命令备注</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/shell.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;chmod命令chmod-755到底是个什么鬼&quot;&gt;chmod命令（chmod 755到底是个什么鬼？）&lt;/h2&gt;

&lt;p&gt;Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。
每个文件的权限呢，又分为读、写和执行。所以，可以用三位二进制来标识权限，当对应二进制位为0时表示没有对应的权限，当对应二进制位为1时表示有对应的权限。比如110，就表时可读可写不可执行。&lt;/p&gt;

&lt;p&gt;那么对应三个用户分组，就需要三组这样的三位二进制来标识权限了。比如111 101 101（rwxr-xr-x），分别（每三位）表示User、Group、及Other的权限。&lt;/p&gt;

&lt;p&gt;对应的，r=4，w=2，x=1
若要rwx属性则4+2+1=7；
若要rw-属性则4+2=6；
若要r-x属性则4+1=5。&lt;/p&gt;

&lt;p&gt;所以755就是11110101（rwxr-xr-x）也就是说文件拥有者有读写和执行的权限，群组和其他用户拥有读和执行的权限。&lt;/p&gt;

&lt;h2 id=&quot;shell命令实现各种进制转换&quot;&gt;Shell命令实现各种进制转换&lt;/h2&gt;

&lt;p&gt;在终端中可以通过printf和echo命令加上表达式即可轻松实现各种进制数之间的互转。我们知道，八进制用o标识，十进制用d标识，十六进制用x标识。&lt;/p&gt;

&lt;p&gt;公式1：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %&amp;lt;目标进制标识&amp;gt; $((原进制标识#原进制数))  &lt;/code&gt; 
公式2：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=目标进制;$((原进制#原进制数))”|bc &lt;/code&gt; 实际上只需掌握这个公式即可！&lt;/p&gt;

&lt;p&gt;二进制转十进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %d $((2#1111)) &lt;/code&gt;           或&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=10;$((2#1111))&quot;|bc    &lt;/code&gt; 
十进制转二进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=2;15&quot;|bc&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=2;$((10#15))&quot;|bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;二进制转八进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %o $((2#1111))&lt;/code&gt;  或   &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=8;$((2#1111))&quot;|bc&lt;/code&gt;
八进制转二进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=2;$((8#17))&quot;|bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;二进制转十六进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %x $((2#1111))&lt;/code&gt; 或  &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=16;$((2#1111))&quot;|bc&lt;/code&gt;
十六进制转二进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=2;$((16#F))&quot;|bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;八进制转十进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %d $((8#17)) &lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=10;$((8#17))&quot;|bc&lt;/code&gt;
十进制转八进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=8;$((15))&quot;|bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;十六进制转十进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %d 0xF 或 echo $((16#F))&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=10;$((16#F))&quot;|bc&lt;/code&gt;
十进制转十六进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %x 15&lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=16;15&quot;|bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;八进制转十六进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;printf %x $((8#17)) &lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=16;$((8#17))&quot;|bc&lt;/code&gt;
十六进制转八进制：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;obase=8;$((16#F))&quot;|bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;

</description>
        <pubDate>Mon, 28 Jan 2019 01:57:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/Shell%E5%91%BD%E4%BB%A4%E5%A4%87%E6%B3%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/Shell%E5%91%BD%E4%BB%A4%E5%A4%87%E6%B3%A8/</guid>
        
        <category>shell</category>
        
        <category>echo</category>
        
        <category>chmod</category>
        
        
      </item>
    
      <item>
        <title>回首2018，我想说的话都在这里</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/2019_new_year.png&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;

&lt;p&gt;年关将至，一直比较忙，没有抽出时间来写一篇年终总结，今天终于得空，我又要开始一个人的叨叨了。&lt;/p&gt;

&lt;p&gt;时间如白驹过隙，2019年已过去近一个月了，2018年的种种都还历历在目。回首2018，有失去父亲的大悲，也有喜得千金的大喜。有悲痛，有喜悦，有遗憾，有收获，也有成长。&lt;/p&gt;

&lt;p&gt;上半年的时候我的父亲病情还有所好转，谁知到了下半年就开始逐渐恶化，再后来，在我刚刚登上飞机的那一刻，我父亲就永远得闭上了双眼，匆匆忙忙赶回家，父亲已经静静地躺在了那口漆黑的棺材里，从此这个家就变成了一个残缺的家。从此阴阳两隔，“爸”这个称呼变成了那座低矮的坟。有些事情就是这么凑巧，有些事情就是这样突如其来，就跟电视里面的剧情一模一样，甚至让你有些怀疑自己是不是在梦中。有多少人会像我这样早早地面临了至亲身患“治也难不治也难”的病时那种艰难的选择，有多少人会像我这样还没到三十而立的年纪就尝到了失去至亲的那种无法言表的悲痛，又有多少人像我这样要这样早早地经历这种丧事下的人情世故。至今每每想起父亲躺在棺材里的那个容貌、那个场景，我都碾转反侧难以入睡。&lt;/p&gt;

&lt;p&gt;因为在我们老家有土葬的风俗，人死后，要请风水先生帮忙在本村选一块合适风水宝地安葬，以保后世太平，如果选到了别人家的地里，就得上门与人好言商量。在我父亲安葬这件事上，让我们看到了人心阴暗的一面。我父亲在世时，向来与人为善，年轻时曾为国效力血战越南战场；父亲也是个篾匠，送人了不少手工编织的箩筐；父亲还是个治小儿惊风的好手，不知道挽回了多少犯急性惊风的孩子。按道理来讲，这样一位大家眼中的好人，死后如果看中哪家的地，不难说下吧？然而，事情远没有我们想想的那么简单，现在世道变了，有的农村人心眼也变坏了。当我父亲快要不行了的时候，我们家请风水先生到处给我父亲选地方，这过程中遇到了不少阻力，就不在这里细说了。我只想说的是：有的人，别看其平常多么像个人样，关键时刻他可能立马变成个鬼来给你看，你永远不知道在你困难时有多少人会在背地里给你补刀。另外，我们年轻人还是要多多努力，现在的人都太势利，我们只有不断增加我们能力的砝码，才能为我们的未来多添一点保障。&lt;/p&gt;

&lt;p&gt;在我父亲去世后不久，我的女儿就出生了，女儿的出生帮我慢慢从悲痛中走出来，尽管从父亲去世到女儿的出生，半个月来我都没有睡到个囫囵觉。讲真，孩子还在肚子里的时候没有太多当父亲的感觉，当孩子出生了，当一个活生生的小娃娃出现在我面前，我的肩头从此多了一份责任，我的心头从此多了一份牵挂。感谢我亲爱的老婆，给我们家新添了一位千金，给我们家注入了新的活力和新的希望。&lt;/p&gt;

&lt;p&gt;2018年，生和死这两件生命中的大事，都让我碰上了。可以说大悲又大喜、大起又大落，犹如坐过山车一般的感觉。不管怎么讲，这两件事都让我成长了不少。但同时遗憾也是终身的，遗憾的是我没有赶上送我父亲最后一程，遗憾的是父亲没有看一眼小孙女再走。在这里我作为过来人，还想奉劝大家一句“珍惜眼前人，珍惜父母，常回家看看”。&lt;/p&gt;

&lt;p&gt;简单聊完了2018年的生活，下面再简单唠叨几句工作上的一点思考和认识。&lt;/p&gt;

&lt;p&gt;2017年底我有幸进入现在这家公司，可以好不夸张地说，2018年我在现在的公司所学到的比在上家几年学到的都要多。现在，我越来越觉得选择真的对一个人太重要了，你选择待在一家浮夸的公司，那么你学到的最多可能就是怎么浮夸起来怎么满嘴跑火车。你选择在一家务实的公司，那么你将学到务实的精神。我们要选择一家对自己能力有提升、对自己未来发展有利的公司，而不要长期待在那种不利于自己职业发展的公司。&lt;/p&gt;

&lt;p&gt;当然，公司好也得我们自己努把力。八小时内谋生存，八小时外谋发展。尽管现在行情一片不乐观，裁员潮一波未平一波又起，各种公司倒闭，各种公司裁员的消息确实不少。但互联网行业毕竟还是朝阳行业，如果互联网行业都不行了，其他行业日子更难过。我们必须清楚什么是公司的，什么是自己的。我们在公司，拿着老板给的工资，就必须好好为公司办事，就必须把自己的工作搞好，这是我们得以生存的保障，只有公司好了，我们这些站在公司这个平台上的人的价值才会凸显出来。另外什么是自己的？想一想我们有一天离开这个公司的舞台，我们的价值是什么，我们还能怎样证明自己的价值。我们应当在把公司的事情尽全力办好的同时一定要抽时间发展与提升属于自己的。属于自己的那个部分，别人是永远拿不走的。不管行业发展到什么时候，优秀的能者一直都是比较稀缺的资源。如果提升自己，只有不断地学习与思考！&lt;/p&gt;

&lt;p&gt;除了不断的学习与思考外，还要勤于总结。在工作之余，我们一定要抽时间做一做总结。我经常和我老婆开玩笑说“像我这样的渣渣写的内容大多都是属于一个人的叨叨，不会有多少人去看的。” 我老婆总是鼓励我说“谁又不是从一个人叨叨开始的呢？” 没错，闻道有先后，术业有专攻，咱不怕写出来的东西在别人眼里显得多么low，通过写作和记录，可以加强我们的记忆、巩固我们的知识结构，如果还能帮助到一部分人那就再好不过了。&lt;/p&gt;

&lt;p&gt;除了提升我们的硬实力外，在工作上要跟同事搞好关系，要多一点团队合作意识，这些都是不管在任何团队里都需要的软实力。如果有可能的话，多提升一下自己在行业内的口碑。举两个最简单的例子吧：&lt;/p&gt;

&lt;p&gt;1.在提交代码的时候写清楚提交日志，不要出现“no message”、”222”、“333”这么高深莫测的提交日志，你永远不知道当你的同事来修改你的代码的时候想打死你几次。每次提交尽可能把颗粒控制得小一点，不要修改了一大堆内容，提交日志却只有几个字。良好的提交日志，会为你赢得同事们的认可，即使你有一天离职了大家都还会记得你好，而不是看到你的代码来一句“卧槽，那个傻逼写得啥鸡巴玩意，那个故作高深的家伙！”。&lt;/p&gt;

&lt;p&gt;2.工作上不要越级刷存在感。即使你的能力强，你的代码水平高，你也一定要明白你的直接领导之所以能当你的领导，那必定是他某方面比你强。不要太自以为是、傲视群雄，也不要思想那么的单纯，不要以为自己比自己直接领导强，通过越级和上面的领导沟通，直接把自己的直接领导给干翻。自从你越级的那一刻，你的处境就已经变得很尴尬很危险了。你的疯狂刷存在感，只会让你团队的成员对你心生厌恶，因为作为程序猿，大家都是相对比较低调的。记住，克制一下程序猿孤傲的臭毛病。&lt;/p&gt;

&lt;p&gt;2018年，我还有一个体会比较深的就是：以前所在的公司，用户量不大，即使线上出了bug，影响也不大。而现在的公司用户量较大，大用户量给我们带来成就感的同时也带来不少压力。我们写代码时就必须谨慎了又谨慎，特别是修改老代码老逻辑的时候更是如履薄冰，稍不注意就会在线上爆炸，线上一旦出现问题，将影响一大片用户的使用和体验。所以，现在写代码必须小心谨慎，尽最大努力降低线上出bug的概率。&lt;/p&gt;

&lt;p&gt;最后，希望大家不负2018，2019年继续努力前行，早日达到人生的巅峰。感谢大家的持续关注与支持！快过年了，提前祝大家新年快乐、阖家欢乐！祝大家2019年技术上更上一个台阶，生活上更加幸福美满！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;
</description>
        <pubDate>Sun, 27 Jan 2019 06:20:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/%E5%9B%9E%E9%A6%962018-%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/%E5%9B%9E%E9%A6%962018-%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/</guid>
        
        <category>life</category>
        
        <category>总结</category>
        
        
      </item>
    
      <item>
        <title>也谈使用NSUserDefaults处理默认值</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/buildings-clouds-dusk.jpg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Cocoa中，NSUserDefaults类的API用于存储和获取用户偏好设置。最近在了解设置webview的UserAgent时第一次用到了NSUserDefaults的&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法，顺带了解一下该方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;始终使用objectforkey方法&quot;&gt;始终使用&lt;code class=&quot;highlighter-rouge&quot;&gt;objectForKey:&lt;/code&gt;方法&lt;/h2&gt;

&lt;p&gt;我一直建议大家使用&lt;code class=&quot;highlighter-rouge&quot;&gt;objectForKey:&lt;/code&gt;方法来获取值，而不是直接使用诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;boolForKey:&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;integerForKey:&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;stringForKey:&lt;/code&gt;之类的方法。因为通过&lt;code class=&quot;highlighter-rouge&quot;&gt;-[NSUserDefaults objectForKey:]&lt;/code&gt;方法来获取值并加上类型判断，可以增强我们程序的健壮性。看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
BOOL showTutorial = [[NSUserDefaults standardUserDefaults] boolForKey:@&quot;ShowTutorial&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时你没有办法判断到底存的值是NO还是没有存过值，如果想做类型区分就很难了，换成下面这样就好区分好理解了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
NSNumber *showTutorial = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;ShowTutorial&quot;];
BOOL shouldShowTutorial = NO;
if(!showTutorial){
//no set yet, put some Extra logic
shouldShowTutorial = YES;
}else{
shouldShowTutorial = [showTutorial boolValue];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;关于registerdefaults方法&quot;&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法可以注册一个包含APP偏好设置默认值的字典，设置之后，在APP中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;objectForKey:&lt;/code&gt;方法获取值时，如果之前没有保存过值，则返回通过&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法注册的默认值。你必须记住的一点是：&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法注册的默认值不会存储到硬盘，只在程序生命周期中有效，所以，你必须每次在程序启动时调用该方法去配置，通常在&lt;code class=&quot;highlighter-rouge&quot;&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;方法中配置。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例子胜千言：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

NSUserDefaults *ud = [NSUserDefaults standardUserDefaults];

//重新启动，之前通过registerDefaults设置的值不存在，说明没有做永久存储。
NSDictionary *rep = [ud dictionaryRepresentation];
NSLog(@&quot;rep=%@&quot;, rep);    


[ud removeObjectForKey:@&quot;name&quot;];
[ud setObject:@&quot;Apes&quot; forKey:@&quot;name&quot;];
[ud registerDefaults:@{@&quot;Apes Talk&quot;: @&quot;male&quot;}];
NSLog(@&quot;name=%@&quot;,[ud objectForKey:@&quot;name&quot;]);//Apes
[ud removeObjectForKey:@&quot;name&quot;];
NSLog(@&quot;name=%@&quot;,[ud objectForKey:@&quot;name&quot;]);//ApesTalk




[ud removeObjectForKey:@&quot;twiceKey&quot;];
[ud registerDefaults:@{@&quot;twiceKey&quot;: @&quot;Apes&quot;}];
[ud registerDefaults:@{@&quot;twiceKey&quot;: @&quot;ApesTalk&quot;}];
NSLog(@&quot;twiceKey=%@&quot;, [ud objectForKey:@&quot;twiceKey&quot;]);//ApesTalk
[ud synchronize];


rep = [ud dictionaryRepresentation];
NSLog(@&quot;rep=%@&quot;, rep);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个常见的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法的例子是设置webview的userAgent，客户端通过在userAgent中加入特殊标识，HTML页面通过这个标识来判断该页面是在APP中加载的还是在浏览器中加载的，以此可以做一些定制化的功能。这里以UIWebView为例，WKWebView在iOS9之后有一个新的设置userAgent的属性customUserAgent。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

//获取webview的默认userAgent
UIWebView *tmpWebView = [[UIWebView alloc] initWithFrame:CGRectZero];
NSString *oldAgent = [tmpWebView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];
//这里以简单的在旧的userAgent后面新增特殊标志为例
NSString * newAgent = [oldAgent stringByAppendingString:@&quot; isInApp&quot;];
//注册
NSDictionary * dictionnary = [[NSDictionary alloc] initWithObjectsAndKeys:newAgent, @&quot;UserAgent&quot;, nil];
[[NSUserDefaults standardUserDefaults] registerDefaults:dictionnary];
[[NSUserDefaults standardUserDefaults] synchronize];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个配置是怎么生效的呢？为什么通过NSUserDefaults设置的默认值为什么会影响到webview？webview在加载的时候是怎么读取userAgent的值的呢？&lt;/p&gt;

&lt;p&gt;实际上，NSUserDefaults有个域domain（由不同级别的层次组成）的概念，每当你获取key对应的value时，NSUserDefaults会在这个域下由上到下查找对应的key，返回第一个找到的值，有点像响应链。域可以持久化存储在硬盘中或只是存储在内存中。&lt;/p&gt;

&lt;p&gt;最重要的一个域是应用程序域（application domain），这里存储着调用&lt;code class=&quot;highlighter-rouge&quot;&gt;set...ForKey:&lt;/code&gt;保存的APP设置信息。相对的，通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法保存的信息存储在低优先级的内存中的registration domain中，作为在应用程序域中找不到的任何值的一个后备（fallback）。&lt;/p&gt;

&lt;p&gt;还有一个全局的域，存储系统范围的设置。特定语言的域存储地区偏好，如每个地区的月名称或日期格式。&lt;/p&gt;

&lt;p&gt;最后但并非不重要的是，苹果使用相同的技术使我们能够通过命令行参数覆盖用户默认值。每个Cocoa应用程序自动检查命令行参数的键/值对，并将这些添加到适当命名的参数域（argument domain）下。由于参数域（argument domain）的优先级最高，我们可以使用它来临时覆盖任何偏好值。&lt;/p&gt;

&lt;p&gt;看到这里我们再回过头想想设置UserAgent的问题，实际上，我们通过高优先级的参数域（argument domain）来临时修改了APP的偏好设置。然后我们可以大胆的猜测一下，UIWebView在加载的时候内部会自动从APP的偏好设置中读取UserAgent的值，所以我们设置的UserAgent才会生效。&lt;/p&gt;

&lt;p&gt;完整的NSUserDefaults的域搜索顺序如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Domain&lt;/th&gt;
      &lt;th&gt;State&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;NSArgumentDomain&lt;/td&gt;
      &lt;td&gt;volatile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Application&lt;/td&gt;
      &lt;td&gt;volatile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSGlobalDomain&lt;/td&gt;
      &lt;td&gt;persistent&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Languages&lt;/td&gt;
      &lt;td&gt;persistent&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSRegistrationDomain&lt;/td&gt;
      &lt;td&gt;volatile&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;另外，通过Settings.bunlde设置的偏好设置信息也需要在程序启动时通过&lt;code class=&quot;highlighter-rouge&quot;&gt;registerDefaults:&lt;/code&gt;方法注册才有效的。Settings.bunlde是个有意思的话题，不过目前使用该技术的APP较少，感兴趣的朋友可以看下这篇文章：&lt;a href=&quot;https://blog.devzeng.com/blog/ios-settings-bundle.html&quot;&gt;iOS开发中Settings.bundle的使用&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://oleb.net/blog/2014/02/nsuserdefaults-handling-default-values/&quot;&gt;Handling Default Values With NSUserDefaults&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.devzeng.com/blog/ios-settings-bundle.html&quot;&gt;iOS开发中Settings.bundle的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;
</description>
        <pubDate>Fri, 11 Jan 2019 02:30:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/%E4%B9%9F%E8%B0%88%E4%BD%BF%E7%94%A8NSUserDefaults%E5%A4%84%E7%90%86%E9%BB%98%E8%AE%A4%E5%80%BCmarkdown/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/%E4%B9%9F%E8%B0%88%E4%BD%BF%E7%94%A8NSUserDefaults%E5%A4%84%E7%90%86%E9%BB%98%E8%AE%A4%E5%80%BCmarkdown/</guid>
        
        <category>iOS</category>
        
        <category>NSUserDefaults</category>
        
        <category>UserAgent</category>
        
        <category>registerDefaults</category>
        
        
      </item>
    
      <item>
        <title>iOS总结-最近遇到的问题及解决办法</title>
        <description>&lt;p&gt;最近在Bugly上发现线上APP存在不少崩溃问题，经过分析和定位，解决了几个比较棘手的问题，总结如下。&lt;/p&gt;

&lt;h2 id=&quot;多线程问题&quot;&gt;多线程问题&lt;/h2&gt;

&lt;p&gt;我们在APP中封装了一个记录业务日志的单例对象，主要代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)shareManager
{
static ATLogManager *manager = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
manager = [[self alloc]init];
});
return manager;
}

- (FMDatabaseQueue *)logDBQueen
{
if(!_logDBQueen){
NSLog(@&quot;创建_logDBQueen&quot;);
NSString *docsDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
NSString *logPath = [docsDir stringByAppendingPathComponent:@&quot;ATLogs&quot;];
NSFileManager *fm =[NSFileManager defaultManager];
NSError *error;
if (![fm fileExistsAtPath:logPath]) {
[fm createDirectoryAtPath:logPath withIntermediateDirectories:NO attributes:nil error:&amp;amp;error];
//禁止iCloud备份
NSURL *downloadsUrl = [NSURL fileURLWithPath:logPath];
NSDictionary *dic = [downloadsUrl resourceValuesForKeys:@[NSURLIsExcludedFromBackupKey] error:nil];
if(!dic || ![[dic objectForKey:NSURLIsExcludedFromBackupKey] boolValue]){
[downloadsUrl setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];
}
}
NSString *dbPath = [logPath stringByAppendingPathComponent:@&quot;ATLog.sqlite&quot;];
_logDBQueen = [FMDatabaseQueue databaseQueueWithPath:dbPath];
}
return _logDBQueen;
}

+ (BOOL)insertLogTableWithType:(NSString * )columnType moreHit:(NSString *)moreHit
{
ATLogManager *manager = [ATLogManager shareManager];
[manager createTable:kFindSelectColumnDate];

//insert code
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之前在用的时候都是在主线程中同步调用相关方法进行记录的，自从上个版本把部分触发比较频繁的记录改成异步的调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_async(dispatch_get_global_queue(0, 0), ^{
[ATLogManager insertLogTableWithType:@&quot;2&quot; moreHit:@&quot;1&quot;];
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后发现线上出现了比较多的崩溃，崩溃在了&lt;code class=&quot;highlighter-rouge&quot;&gt;[FMDatabaseQueue inDatabase:]&lt;/code&gt;方法中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/fmdb_crash_issue.png&quot; alt=&quot;fmdb_crash_issue&quot; /&gt;&lt;/p&gt;

&lt;p&gt;起初以为是FMDatabaseQueue的问题或者我们用的FMDB的版本较低的问题。但是FMDatabaseQueue本身是线程安全的，在多线程中使用同一个FMDatabaseQueue对象是没有问题的。FMDB这个第三方库，这么多用户，用了这么多年，应该是不会存在这种问题的。程序崩溃在这里，而且是SEGV_ACCERR类型的崩溃，只能是在FMDatabaseQueue使用过程中被释放了造成的。&lt;/p&gt;

&lt;p&gt;在我们封装的记录业务日志的单例对象中，有一个FMDatabaseQueue对象是采用懒加载的方式创建的，经过一番排查，发现这个FMDatabaseQueue对象竟然被创建了多次。这下子就豁然开朗了，在多线程并发的情况下，第一次创建的FMDatabaseQueue对象正在执行相关代码时，第二次紧接着调用了懒加载的方法创建了一个新的FMDatabaseQueue对象把第一个创建的给覆盖掉了，这时第一次创建的FMDatabaseQueue对象就被释放了，这个时候就存在很多不安全的隐患了，比如我们这里就是导致访问了一个不合法的内存地址。&lt;/p&gt;

&lt;p&gt;解决办法就是把懒加载的方法给移除，单例创建时就把对应的FMDatabaseQueue对象给创建了，保证FMDatabaseQueue只会创建一个。&lt;/p&gt;

&lt;p&gt;这个事情给我了一个比较大的教训，在使用单例的时候，一定要小心通过懒加载方式创建的属性，在多线程下一定要注意懒加载方法被调用多次。在单例的初始化方法中最好将它的属性都一并给初始化了，这样能有效保障线程安全。&lt;/p&gt;

&lt;h2 id=&quot;preferredmaxlayoutwidth&quot;&gt;preferredMaxLayoutWidth&lt;/h2&gt;

&lt;p&gt;在iOS10.2上某个页面总是点击进去就闪退，经过排查发现在计算某个UITableViewCell的高度时出现的crash，cell本身没有任何特别的，如果把cell上多行的UILabel给注释掉，就没有问题了。最后在UITableView-FDTemplateLayoutCell的&lt;a href=&quot;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/issues/278&quot;&gt;issue278&lt;/a&gt;找到了答案：多行UILabel如果不设置preferredMaxLayoutWidth，走到fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;会在iOS10.2的机器上卡死奔溃，应该属于系统问题。&lt;/p&gt;

&lt;h2 id=&quot;block&quot;&gt;block&lt;/h2&gt;

&lt;p&gt;开发过程有个在多线程中处理数据时出现了数组越界的问题，经检查发现是我们犯了一个关于block的低级错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//不加__block打印i=0（捕获后外部的修改不影响内部使用）；加__block打印i=1（外部的修改对block内部生效）
for(__block NSInteger i = 0; i &amp;lt; 1; i++){
dispatch_async(dispatch_get_global_queue(0, 0), ^{
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
NSLog(@&quot;i=%ld&quot;,i);
});
});
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;uiwebselectsinglepicker的crash问题&quot;&gt;UIWebSelectSinglePicker的crash问题&lt;/h2&gt;

&lt;p&gt;另一个数组越界问题，但是查看奔溃堆栈信息，发现内容是包含UIWebSelectSinglePicker、UIPickerView、UIPickerTableView等关键字，据此猜测是我们项目中嵌入的H5页面调用系统的选择视图引起的崩溃。查资料发现，已经有人遇到这种情况了，重现步骤：H5唤起系统的UIPickerView，没有数据源的情况下，上下滑动一下再点击确定选择。详情可参考这篇文章：&lt;a href=&quot;https://juejin.im/post/5b14cf376fb9a01e831463d6&quot;&gt;UIWebSelectSinglePicker的crash问题&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;
</description>
        <pubDate>Sun, 23 Dec 2018 04:10:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/iOS%E6%80%BB%E7%BB%93-%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/iOS%E6%80%BB%E7%BB%93-%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
        
        <category>iOS</category>
        
        <category>bug</category>
        
        <category>crash</category>
        
        <category>fmdb</category>
        
        <category>多线程</category>
        
        <category>preferredMaxLayoutWidth</category>
        
        <category>block</category>
        
        <category>UIWebSelectSinglePicker</category>
        
        
      </item>
    
      <item>
        <title>关于符号表（dSYM）的误解与事实</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/misunderstand_truth.jpg&quot; alt=&quot;misunderstand_truth&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在iOS开发过程中一定会跟符号表（dSYM文件）打交道，它是我们不可或缺的定位bug的小帮手。我们都知道，每次编译都会生成一个dSYM文件，当我们的应用程序出现奔溃时，dSYM文件能帮我们定位到应用程序的代码奔溃到哪里了。&lt;/p&gt;

&lt;p&gt;最近在开发过程中遇到这样一个问题：我们的团队中有的成员用的是Xcode9，有的成员用的是Xcode10，Xcode10在打包时如果把Debug Information Format设置为DWARF with dSYM File，在打包时会导致电脑内存耗尽关机。所以在开发过程中，我们把配置都改成了DWARF。最后在用Xcode9打包的时候，忘记了修改这项配置，没有生成符号表上传到Bugly，所以线上的奔溃信息没法解析出来。这件事情引发我们的思考，面对这种情况，到底有没有什么补救措施呢？&lt;/p&gt;

&lt;h2 id=&quot;dsym文件简介&quot;&gt;dSYM文件简介&lt;/h2&gt;

&lt;p&gt;符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;起始地址&amp;gt; &amp;lt;结束地址&amp;gt; &amp;lt;函数&amp;gt; [&amp;lt;文件名:行号&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;iOS应用crash时也有堆栈，release版的应用，crash时的堆栈信息，全是二进制的地址信息。如果利用这些二进制的地址信息来定位问题是不可能的，因此我们需要将这些二进制的地址信息还原成源代码种的函数以及行号，这时候就需要符号表了。&lt;/p&gt;

&lt;h2 id=&quot;误解与事实&quot;&gt;误解与事实&lt;/h2&gt;

&lt;p&gt;我们都有这样一个共识：“每次打包都会生成一个新的dSYM并生成一个新的uuid，线上app也有一个uuid，只有这两个uuid匹配，才能成功解析二进制地址信息为源码。” 很惭愧，以前由于本人思维定式（估计很多人跟我一样吧，我发现网上很多文章也是这么讲的）认为每次打包都会生成一个全新的唯一的uuid，所以，如果打版时忘记勾选生成dSYM文件，将毫无补救办法。官方也没有任何关于这个uuid的生成规则的说明。&lt;/p&gt;

&lt;p&gt;网上的一些文章关于这一块讲的要么模棱两可，要么讲的是错误的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/lead young people astray.png&quot; alt=&quot;lead young people astray&quot; /&gt;&lt;/p&gt;

&lt;p&gt;让我们再看看上面dSYM文件的介绍，它跟函数名、文件名和行号有关。&lt;strong&gt;简单点说就是同一份代码，编译之后的符号表文件的uuid是一样的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以这个时候我们只需要找到上一次打包的那个时间点（代码相同），再重新archive一下，导出dSYM文件，这个dSYM文件的uuid跟之前打包生成的app的uuid是一致的。&lt;/p&gt;

&lt;p&gt;下面是有图有真相，同一份代码，不同时间点打的包的uuid是一样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/dSYM-uuid.png&quot; alt=&quot;dSYM-uuid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实践是检验真理的唯一标准。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;

</description>
        <pubDate>Sun, 23 Dec 2018 03:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/%E5%85%B3%E4%BA%8E%E7%AC%A6%E5%8F%B7%E8%A1%A8-dSYM-%E7%9A%84%E8%AF%AF%E8%A7%A3%E4%B8%8E%E4%BA%8B%E5%AE%9E/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/%E5%85%B3%E4%BA%8E%E7%AC%A6%E5%8F%B7%E8%A1%A8-dSYM-%E7%9A%84%E8%AF%AF%E8%A7%A3%E4%B8%8E%E4%BA%8B%E5%AE%9E/</guid>
        
        <category>iOS</category>
        
        <category>符号表</category>
        
        <category>dSYM</category>
        
        <category>uuid</category>
        
        
      </item>
    
      <item>
        <title>缅怀我的老父亲</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/I_miss_you_dad.jpg&quot; alt=&quot;I miss you, dad&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;穷山恶水白手起家&quot;&gt;穷山恶水，白手起家&lt;/h2&gt;

&lt;p&gt;我的父亲出生于1956年，不久后我爷爷就去世了，家里一贫如洗，家里的重担一下子全压在包了小脚的奶奶。在那个人情淡薄的年代，我奶奶差点被爷爷的堂兄弟给卖掉。由于从小家里条件就差，时常吃不饱饭，大饥荒留下的阴影还时常笼罩在人们的心头，让父亲养成了一粒米掉地上都要捡起来吃掉的习惯。&lt;/p&gt;

&lt;p&gt;在那个贫穷和饥饿的年代，农民没有太多出去工作的机会，大家只能守在家里的一亩三分地里，谁家里地多谁家条件就好一些，至少没有那么饥饿。而且种地还要上缴一部分给国家，剩下的才是自己的，大家都是靠天吃饭，如果年景不好，可能就会导致自己一家子饿肚子不说还被国家催着缴粮。地，是大家的宝，谁家地多，谁家就没那么饥饿。但是我们家那时候劳动力少，分到的地也就少，家里的粮食经常上茬接不住下茬。&lt;/p&gt;

&lt;p&gt;这些经历让父亲非常害怕饿肚子，直到现在，他也不允许把家里的粮食卖完了，家里一定要囤粮食，以防再遇到天灾全家人饿肚子。家里有粮，他才过得踏实。&lt;/p&gt;

&lt;p&gt;到了父亲正值身强力壮的青年时期，家里孩子多，地还是少，日子还是过得紧巴巴的。为了能获得更多的粮食，父母经常自己家地里活干完了去帮别人地多的人家干活，有时候能换回来一点点粮食。如果换回来次一点的花生，从中挑一点稍微好点的做种子种到自己的地里。为了省下粮食，平常做饭上面父母也很有自己的一套，白米细面不够，就拿粗粮凑。比如煮一锅红薯，里面放几根面条；煮一锅米饭就上面一层米下面大半的红薯或酸菜。只有过年的时候父母才会很讲究的煮一大锅白米饭，里面不加任何粗粮，有时候如果母亲习惯性的放了点粗粮会被父亲凶。这样做的目的就是给新年一个好兆头，期盼家里米足面足，每天都能吃到纯白米饭的日子快点到来。&lt;/p&gt;

&lt;p&gt;这种紧巴巴的日子就这么一天天的过着，到后面可以去外面打工的年代，母亲守在家里种地带孩子，父亲跟着别人去砖厂、去建筑队干活，全是出力气的重活累活。从跟父亲一起打工的人那里得知，父亲不管在哪，不管干什么重活，都舍不得吃舍不得喝，往往都是开水泡白馒头糊弄一下，就为省下更多的钱，让这个家的日子早点过得好起来。&lt;/p&gt;

&lt;p&gt;在没有任何家底的情况下，父亲带着我们一家熬了过来。在没有其他经济来源的情况下，是父亲一边打工，一边勒紧自己的裤腰带，从自己牙缝里抠出来的一点点钱慢慢为家庭积累财富。为了摆脱土房子，防止以后自己孩子找不到老婆，父母在2002年鼓起勇气把楼房给盖起来了。之后父亲又辛辛苦苦打了很多年的工才把欠下的账给还清。&lt;/p&gt;

&lt;p&gt;我们这个家能走到现在，父亲吃了太多的苦头，个头不高的父亲顶起了这个家庭的天，是他用自己的血汗为我们筑起了一个遮风挡雨的温暖的家。&lt;/p&gt;

&lt;h2 id=&quot;战争的摧残&quot;&gt;战争的摧残&lt;/h2&gt;

&lt;p&gt;“好男人当兵去，当出个样儿来给爹娘看”。当兵，大概是父亲他们那代人年轻时可选的一条好路子。当年的父亲雄心壮志，浑身是胆，誓为报效祖国奉献自己。由于我爷爷走的时候只留下一座茅草屋，父亲不得不自己挖一个屋宅地并盖起了一座土胚房，土房子盖好之后父亲就在全村敲锣打鼓的欢送中怀着一片赤子之心从军去了。1979年，父亲从军的第四个年头，爆发了对越自卫还击战，父亲所在的尖刀连被抽调到了前线。在全民皆兵的越南战场上，在枪林弹雨下父亲跟战友们和敌军进行了殊死搏斗。在一次双军交战的过程中，父亲被落在附近的炸弹炸伤，之后带着军队上的表彰退役回家，庆幸父亲能从战场上捡回一条命。父亲是一个话不多的人，一直以来也没从他口中听到太多关于当年战争的细节部分，只听父亲讲过在全民皆兵的越南战场上非常危险，不仅要随时准备和突然冒出来的敌军展开搏斗，还要提防越南民兵设下的陷阱和埋下的地雷，稍有不慎就会断送掉性命。&lt;/p&gt;

&lt;p&gt;处在和平时代的我们，对战争已经没有了什么概念，我们今天的幸福是千千万万个像父亲一样伟大的军人为我们打下来的，有句话说得好，“哪有什么岁月静好，只不过有人替你负重前行”。&lt;/p&gt;

&lt;p&gt;听说，当时部队上曾经讲过会给他们这些立过功的退役军人一个“交代”，但父亲回家之后一直得不到什么“交代”，哪怕是安排进厂子当工人。在我朦胧的记忆里，父亲有在母亲的怂恿下提着土鸡去送给相关领导，鸡送没送出去我不记得了，只记得父亲回来时很气愤。我能体会得到这种送礼的事情让一位刚正不阿的老战士去做，对父亲来说太难为情了。&lt;/p&gt;

&lt;p&gt;也许是战场上血淋淋的残酷，也许是退伍后现实中的各种不如意，父亲变了，曾经母亲提议让孩子们去当兵，父亲说当兵太苦，坚决不同意。&lt;/p&gt;

&lt;h2 id=&quot;两根银针治惊风&quot;&gt;两根银针治惊风&lt;/h2&gt;

&lt;p&gt;小时候，农村医学提交非常贫乏，那时候小孩子很容易患惊风，四肢抽搐、口吐白沫、翻白眼，时有患了急性惊风而没来得及医治的孩子夭折。我们家孩子又多，孩子一翻白眼就把父母吓个半死。除了惊风，小孩子玩水还容易肚子疼，俗称“伤水”。总之，小时候生病了是个比较麻烦的事情，记忆中在月黑风高的晚上，在父母的背上迷迷糊糊的睡，父母得把我们背着走好几里路，翻过几个山丘才能找到一个郎中帮忙看一看。&lt;/p&gt;

&lt;p&gt;已经不记得是从什么时候开始，父亲不知道从哪里买到两根细如麦芒的银针，摇身一变，成了一个会针灸还会给别人弄中药的土郎中。自那以后，我们再患惊风或者肚子疼，父亲拿起银针一扎就好了。同村的也时常带着孩子来让父亲帮忙医治，曾经有几个患上急性惊风的孩子被父亲救了下来。虽然家里穷，但是父亲给人看病从不收钱，父亲平时遇到可用的中药就会采回来放在窗子上晒干囤着，有时候孩子感冒或者常见的头疼发热，父亲就配一点中药送给别人。父亲就是这么个为人，他一般不愿意麻烦别人，别人有事找上他，他会不遗余力帮助别人。&lt;/p&gt;

&lt;h2 id=&quot;玩转篾刀&quot;&gt;玩转篾刀&lt;/h2&gt;

&lt;p&gt;在农村，竹制品一直是用的比较多的，比如箩筐、竹篮、饭筐、晒席、睡席、竹筛子、竹耙子、篱笆栅栏等等。不知不觉间，父亲又弄了一套篾匠用的工具：篾刀、度篾齿、卷尺、小锯子……用的最多的就是篾刀，篾刀很重，它看起来很笨重，但是在父亲的手上却显得很轻巧很灵活。一根根竹子经过父亲的双手，变成了青篾和黄篾，青篾韧性好，用于制作需要弯曲的工具；黄篾韧性差，一般做篱笆栅栏。制作不同的竹制品需要不同的竹篾，有的宽，有的细，有的长，有的短。篾刀在父亲的手上就像一把魔术刀，不一会就能把竹子劈成各种需要的尺寸，再经过一番编制就变成了有模有样的各种精巧的竹制品。从小到大，家里用的装粮食的竹篮竹筐、装饭菜的饭筐、竹筛子、竹耙子都是父亲亲手编制的，为家里省下来不少钱。&lt;/p&gt;

&lt;p&gt;别人家看到我们家的竹制品制作的比较精致好用，经常趁父亲在家有空的时候找父亲帮忙编。同样的父亲也是从来不收钱的，一般亲戚和邻居从家里扛点竹子过来就可以了。&lt;/p&gt;

&lt;h2 id=&quot;计划生育之伤&quot;&gt;计划生育之伤&lt;/h2&gt;

&lt;p&gt;我们家孩子多，那时候赶上计划生育政策很严的年代，父母因为我们吃了不少苦头。我们小时候为了躲避罚款，每每听到计划生育的人来了，赶紧往树林里跑。有时候不得不在远方的亲戚家住很长时间。那是个人情淡薄的年代，那时候负责计划生育的人就跟现在的城管一样，时常有暴力执法的事情发生，比如拆房子、拉牲口、拉家里的家具，很难想象历史是如此的相似。有的人会看在父亲曾经上过战场的份上不动我们家的东西，有的人不会。有一次，我们家的缝纫机被抬走了，老黄牛差点被牵走，这件事真是激怒了父亲，父亲差点拿起铁锹起来反抗。可以想象父亲当时是多么的愤怒，一个曾经在战场上奋勇杀敌的老战士，在战场上不惜抛头颅撒热血的军人，回到农村却不能安居乐业，要被这帮手上有小小权利的人欺负到地缝里。&lt;/p&gt;

&lt;p&gt;孩子们渐渐长大，终究是躲不过上户口这一关的，父亲为了给我们上户口差点跑断腿，要各种找关系、要低头哈腰、要强颜欢笑。能脸不红心不跳地做这种事情的人是父亲非常鄙视的人，身为军人，军队曾经教会他要忠于国家忠于党和人民，要为人正直、刚正不阿。然后在现实中，这套逻辑却输给了现实，输得那么干净。现实，给了父亲当头一棒，让他不得不去做违心的事情，不得不去做他非常厌恶的事情。现实，让多少像父亲这样的英雄流血又流泪。&lt;/p&gt;

&lt;h2 id=&quot;癌症之痛&quot;&gt;癌症之痛&lt;/h2&gt;

&lt;p&gt;时光飞逝，转眼父亲到了中老年，家里的日子眼看一天天变好了，没有了吃不饱穿不暖的苦日子和计划生育。每顿都可以炒俩菜喝点小酒，每天都可以吃到白米细面。然而，好景不长，我们谁也想不到，癌症会突然强行闯入父亲的晚年生活。&lt;/p&gt;

&lt;p&gt;2016年下半年，父亲吃饭开始有点噎，去医院检查说是胃癌，当时把父亲都吓哭了。是啊，心疼我那可怜的老父亲呐，辛苦劳累了一辈子，白手起家，终于把日子过出了个名堂，小时候是没得吃，年轻的时候是勒紧裤腰带舍不得吃，好不容易熬到可以放开了吃的年代，上天却无情地把吃这扇窗关上了。&lt;/p&gt;

&lt;p&gt;几十年的苦和累把父亲这位军人强壮的身体变得疾病累累，肩周炎、腰椎间盘突出一直折磨着父亲。刚开始我们想通过中医调理的方式抑制父亲的癌症，但眼看不做手术不行，2017年初，父亲做了手术，把多半的胃切除了。之后又做了几次放疗和化疗，父亲的身体变得越来越虚弱了，虚弱得经不起再放疗化疗了。因为一直吃不下喝不下，营养一直跟不上，父亲的身体一天天的消瘦下去，腹部完全坍塌下去，前胸贴到了后背上。&lt;/p&gt;

&lt;p&gt;2018年，父亲的情况更加恶化了，去医院检查发现癌细胞已经扩散到了肺部，医生建议做造瘘手术，父亲觉得自己已经经不起再做手术了，父亲想要保留一个完整的身体，不同意再做手术。我们不得不尊重父亲的意愿，把父亲从医院里带回家。在家里坚持了几天，饿得受不了了，不得不再次转到离家近的镇医院里打营养液维持生命。 看着父亲的身体饱受癌症的摧残，我们的内心同样饱受折磨。曾经，父亲可以为我们付出一切，为我们撑起一片天，如今我们能为父亲做的却非常有限，我们不能分担父亲的疼痛，不能让父亲想吃啥吃啥想喝啥喝啥。&lt;/p&gt;

&lt;p&gt;在最后的一个半月里，是父亲十分煎熬的一段时间，吃什么都往外吐。到了最后，感觉器官都在腐烂，隔三差五吐出一些带着血腥味的东西，黑红黑红的，尿都变红了。父亲可能感觉到自己时间不多了，主动要求要吃点红薯、吃点柿子、吃点罐头，虽然都是吃了又吐出来，只是过过嘴瘾罢了。&lt;/p&gt;

&lt;p&gt;2018年10月30日我坐上了回家的飞机，等到了中午下飞机后我打开手机的时候发现10:08，我刚坐上飞机关机那会，哥哥们就已经给我发消息说父亲已驾仙鹤去。当时我的眼泪就歘歘的下来了，最终还是没赶上见父亲最后一面，喊父亲最后一声，苍天啊，你为什么要这么捉弄我，明明当天我就能赶回家，为什么不能让父亲再等我几个小时，为什么要给我这一生留下这么大一个遗憾。以前回家，是父亲坐在门口等着我回来，这次回家，等我的是一口漆黑冰冷的棺材和一张黑白照片，内心的崩溃无以言表。在父亲的棺材前守了两晚上的灵，一直等到在最后一次开棺供大家见最后一面的时候我才再次见到父亲的面容，枯瘦的身材已经撑不起年轻时穿的尺寸的军装，眼睛凹陷，颧骨高高凸起，嘴巴饿得长得大大的露出一口白牙。看在眼里痛在心里，母亲和我们哭成一团，我的苍天呐，你为什么这么地不公啊，为什么不能给像父亲这样善良而又伟大的人一个善终啊。&lt;/p&gt;

&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;父亲，您是儿子的山，你为儿子顶着天；您是儿子的海，不管什么时候你都包容着儿子的错；您是儿子的灯，为儿子指明前进的方向。&lt;/p&gt;

&lt;p&gt;是您，进可上阵杀敌保家卫国，退可自学成才救死扶伤。是您，像变魔术一样，家里需要什么您就变出什么。是您，用自己的节省，给我们省出了房子，省出了读书的机会。是您，像蜡烛一样燃尽自己最后一丝能量，为我们带来光明和温暖。是您，在平凡中铸就伟大，您永远是我们心中的英雄。&lt;/p&gt;

&lt;p&gt;父亲，感谢您一生的无私奉献和付出，感谢您的养育之恩，感谢您陪我们长大。如果有来生，我希望能成为可以走进您内心的、懂您的女儿，我一定会记得提醒您不要为了省钱亏待了自己的胃，不要那么固执，对自己好点；我一定会记得缠着您让您把心里话说出来，别憋在心里生闷气；我一定会记得在家附近找份工作，这样就可以多点时间陪伴您。&lt;/p&gt;

&lt;p&gt;愿父亲大人一路走好，愿天堂没有癌症！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;

</description>
        <pubDate>Tue, 13 Nov 2018 03:30:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/%E7%BC%85%E6%80%80%E6%88%91%E7%9A%84%E8%80%81%E7%88%B6%E4%BA%B2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/%E7%BC%85%E6%80%80%E6%88%91%E7%9A%84%E8%80%81%E7%88%B6%E4%BA%B2/</guid>
        
        <category>父亲</category>
        
        <category>情感</category>
        
        <category>个人</category>
        
        
      </item>
    
      <item>
        <title>阿里API网关使用总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;最近大半年的时间里，为了加强公司API的安全性，公司尝试了接入阿里API网关的服务。在这期间，由我调研和宣贯阿里API网关的使用并基于AFNetworking封装一个方便我们内部使用的带阿里API网关的网络请求框架。本篇介绍一下API网关的使用流程和我们在使用期间遇到的各种问题以及解决方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://help.aliyun.com/product/29462.html?spm=a2c4g.750001.3.46.4cc17b13RVNrsQ&quot;&gt;API网关&lt;/a&gt; API Gateway）提供高性能、高可用的 API 托管服务，帮助用户对外开放其部署在 ECS、容器服务等阿里云产品上的应用，提供完整的 API 发布、管理、维护生命周期管理。用户只需进行简单的操作，即可快速、低成本、低风险地开放数据或服务。&lt;/p&gt;

&lt;p&gt;利用API网关你可以提高自己公司API安全性，也可以上架到API云市场，供用户购买和使用。&lt;/p&gt;

&lt;h2 id=&quot;一阿里api网关的基本使用流程&quot;&gt;一、阿里API网关的基本使用流程&lt;/h2&gt;

&lt;h3 id=&quot;1创建应用获取appkey和appsecrect&quot;&gt;1、创建应用获取AppKey和AppSecrect&lt;/h3&gt;

&lt;p&gt;这个没什么可说的，主要是你要想办法尽可能安全地存储你的AppKey和AppSecrect。&lt;/p&gt;

&lt;h3 id=&quot;2创建api分组&quot;&gt;2、创建API分组&lt;/h3&gt;

&lt;p&gt;所属分组是API的基本属性，所以需要先创建分组，再在分组下创建API。每个账号默认最多可创建100个分组，如需更多分组需要提交工单。分组有所属区域（Region）的概念，比如华东上海区，选择之后就不能修改了。创建完分组之后，系统会给该分组分配一个二级域名，供测试使用，不过，每个二级域名每天最多可访问1000次。&lt;/p&gt;

&lt;h3 id=&quot;3为api分组绑定域名和证书&quot;&gt;3、为API分组绑定域名和证书&lt;/h3&gt;

&lt;p&gt;如果你的API支持HTTPS协议，还需要为该独立域名上传 SSL 证书。我们需要把我们的域名解析到该分组上，之后才能绑定到该分组上。绑定的域名需要现在阿里云系统备案。绑定域名之后，该分组下的API就可以通过该域名来访问了，不再需要调用系统分配的二级域名了。&lt;/p&gt;

&lt;h3 id=&quot;4环境管理可选&quot;&gt;4、环境管理（可选）&lt;/h3&gt;

&lt;p&gt;在API分组的环境管理中，你可以自定义环境变量，同一个变量可以再在线上、预发和测试三个环境下对应不同的值，这样在API的定义中就可以使用这里定义好的环境变量了。可以在Path、入参默认值和后端服务服务地址中加入环境变量，在API的定义中使用环境变量需要以&lt;code class=&quot;highlighter-rouge&quot;&gt;#变量名#&lt;/code&gt;的方式使用。&lt;strong&gt;如果要修改已发布的API用到的环境变量，先把老的环境变量给删掉，再重新定义一个新的同名环境变量赋上新值之后再把全部对应的API重新发布一遍，这个是异步生效的，一般发布后1分钟内生效。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;5创建api&quot;&gt;5、创建API&lt;/h3&gt;

&lt;p&gt;这里的内容还是蛮多的，包括基本配置，前端和后端地址，请求参数配置等，详细文档可以看阿里API的官方文档，这里说几点重要的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;API名字虽然可以随便取，但建议保持跟API的实际名字保持一致，方便搜索和管理；&lt;/li&gt;
  &lt;li&gt;入参映射与入参透传的区别：入参映射需要你根据实际API需要参数，逐一录入API网关，通过映射关系，可以将参数映射到服务端上，一般情况下，比如我们请求的时候放在Query中，服务端也去Query中拿值，通过入参映射，我们可以实现请求的时候参数放在Header中，阿里API网关在转发到我们服务端的时候可以帮我们转发到Query中。入参映射可以实现阿里网关层的参数合法性校验（网关会参照校验规则对请求做初步校验，如果入参不合法
，则不会到达您的后端服务，大大的降低了后端服务的压力），因为我们可以在每个参数后面“编辑更多”中指定参数的限制规则，比如长度限制、验证正则表达式等。入参透传的话不需要我们定义参数，阿里网关在收到我们请求的时候直接转发给我们的服务端。我们一般使用入参映射，因为这样对于我们的API需要的参数一目了然，而且以后如要加什么参数限制规则，也是很方便的。&lt;/li&gt;
  &lt;li&gt;通过阿里API网关，我们还能实现请求的地址跟后端服务地址不一样的效果。比如我们请求的地址可以定义成“https://yourdomain.com/fake/fakeSaveUserInfo”，后端服务地址写上我们真正的服务端请求地址“https://yourdomain.com/real/realSaveUserInfo”，网关在收到我们的服务请求时会自动帮我们转发到真正的后端服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6api授权&quot;&gt;6、API授权&lt;/h3&gt;

&lt;p&gt;创建好API之后，就可以对应用进行授权了，点击API的“授权”就可以在指定环境下授权某个APP可以访问该API了，如果你在调用API的过程中控制台打印了x-ca-message中包含了Unauthorized错误，你应该想到你的API还未对该APP进行授权访问。&lt;/p&gt;

&lt;h3 id=&quot;7api发布&quot;&gt;7、API发布&lt;/h3&gt;

&lt;p&gt;API编辑完成之后就可以发布到指定环境上去了，发布之后就立马生效了。可以多次编辑然后发布到不同的环境下，如果你编辑完了忘记发布到指定环境下了，是不会生效的。在分组API列表下，直接点击API名字进入的是当前API最后一次编辑保存的状态，不一定跟发布的状态一直哦。点击API右边的线上、预发或测试后面的”运行中”可以看到在该环境下最后一次编辑发布后的状态哦。&lt;/p&gt;

&lt;h2 id=&quot;二签名规则&quot;&gt;二、签名规则&lt;/h2&gt;

&lt;p&gt;网关会在请求的时候加上日期、时间戳、nonce、userAgent、Host、AppKey、version等参数值，如果是POST请求的话，需要对参数值进行urlEncode。如果有body值的话，需要对body值，将body中的内容MD5算法加密后再采用BASE64方法Encode成字符串，放入HTTP头中。最后再通过将httpMethod、headers、path、queryParam、formParam经过一系列的运算，合成一个字符串用hmacSha256算法双向加密进行签名。&lt;/p&gt;

&lt;h2 id=&quot;四环境的区分&quot;&gt;四、环境的区分&lt;/h2&gt;

&lt;p&gt;在我们分组上绑定好了域名之后，我们不管是预发还是线上环境都可以通过这同一个域名进行访问，那网关是怎么帮我们区分环境的呢？这个时候就用到上面的环境变量管理了，我们通过在环境变量中定义一个变量在不同环境下不同的值达到区分环境的效果。在网络请求的时候，我们可以在头部指定&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Ca-Stage&lt;/code&gt;参数值来让网关帮我们转发到对应环境的后端服务上，对应的值分别是：线上（RELEASE）默认、预发（PRE）和测试（TEST）。&lt;/p&gt;

&lt;h2 id=&quot;三参数位置和emoji&quot;&gt;三、参数位置和emoji&lt;/h2&gt;

&lt;p&gt;这里重点说一下参数位置下可选的Body选项，这个地方坑了我们蛮久。我们知道在我们客户端发起POST请求时，我们会在头部指定“Content-Type”为“application/x-www-form-urlencoded”，然后把请求的参数组装成”key1=value1&amp;amp;key2=value2”的字符串，然后在编码成二进制，放在请求的Body里，以Form表单的形式提交的。所以呢，我们在定义API的参数时，应该把参数位置选择为Body选项。但是我们在很长一段时间里，创建API时或编辑API时，参数位置处下拉一直没有Body选项，我们就把参数定义成了Query类型的了。在使用时也没有啥问题，但是一旦当我们的参数值非常长时，比如一个json字符串，这个是就报错了“414 Request-URI Too Large”，这个时候呢，网关就不会再帮我们把请求转发到服务端了。排查了很久终于找到了罪魁祸首在这里等着呢，通过把参数位置改成Body就可以了。这个可能是阿里API网关前端页面上的一个bug，有时候根本选不到Body选项，这个时候你可以先把“请求Body（非Form表单数据，比如JSON字符串、文件二进制数据等）”选项给勾选上，然后再取消勾选，再下拉展开“参数位置”就可以看到Body选项了。（该文发布时是如此，我已经将该问题反馈给阿里API网关，可能后面会修复该bug。）&lt;/p&gt;

&lt;p&gt;另外一个问题是如果你的参数值中包含了emoji表情，需要对参数值进行urlEncode，服务端在收到请求时需要对参数值进行urlDecode。否则用的过程中会出现各种奇怪的问题。问了阿里网关的服务人员，他们的解释是，如果不进行urlEncode，参数在传到网关时可能会丢失。可以对所有Post请求的参数值统一urlEncode，服务端对收到的参数值统一进行urlDecode。&lt;/p&gt;

&lt;h2 id=&quot;四timestamp和nonce防重放攻击&quot;&gt;四、timestamp和nonce防重放攻击&lt;/h2&gt;

&lt;p&gt;在使用网关时，timestamp和nonce这两个header参数值是可选的，如果加上这两个值，网关层会对请求进行校验，防止重放攻击。不过有个问题：在当前时间的前后15分钟的时间戳都是可以的，一旦超过15分钟就会请求失败，所以，如果用户修改了客户端的系统时间的话，API就会调不通了。这个校验有点严格，如果不知道这一点的话，用户反馈客户端不能用，而你这里测试又没有任何问题，那就泪奔了，哈哈。当然这个是可选的校验，如果不传这两个值的话，就不会校验，这个时候防重放攻击的工作就需要我们自己的服务端做了。&lt;/p&gt;

&lt;h2 id=&quot;五上传文件&quot;&gt;五、上传文件&lt;/h2&gt;

&lt;p&gt;目前网关不支持multipart形式的上传，所以一般我们的上传API不太适合录入网关，阿里的说法是现在大家的做法普遍是先将文件上传到文件服务器，然后通过调用接口把文件地址等信息报错到服务器的方式，所以，目测以后也不大可能支持定义multipart形式的上传API。&lt;/p&gt;

&lt;h2 id=&quot;六qps与流量控制策略&quot;&gt;六、QPS与流量控制策略&lt;/h2&gt;

&lt;p&gt;每个 API 分组的默认流控上限是500QPS，如果你要调大QPS，需要提交工单并支付相应费用。另外网关有个“流量控制策略”的功能，它是针对API的，也就是说定好策略之后，选中对哪些API生效，这些API就会单独的受这个流量控制策略的控制。但是，需要注意的是，如果你要调大流量控制策略，也必须先调大API所在分组的QPS才会生效，否则流量控制策略可以创建但不会实际生效。&lt;/p&gt;

&lt;h2 id=&quot;七建议&quot;&gt;七、建议&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;1、一个API分组对应一个我们真正的服务域名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然我们可以在分组的环境管理中添加不同的环境变量来实现同一个API分组下可以定义不同服务域名的API，这样我们客户端在发起请求的时候，域名只需要配一个就可以了，非常方便。但是，一旦网关这一层瘫痪（尽管是小概率事件，但不排除），这个时候我们就心有余而力不足了，只能等网关尽快恢复了。如果我们一个分组对应一个我们真正的服务域名的话，一旦网关出问题，我们可以快速把该分组绑定的域名指向我们真正的该分组的服务上。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2、POST请求一定要把参数位置选为Body&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3、考虑到分组的QPS，每个分组内的API不应过多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4、没有参数的API必须定义成GET方式的请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5、网关控制台定义的API名字最好跟后端实际使用的API名字保持一致，因为网关控制台的API搜索功能只能搜索定义的API名字，不能搜索后端真实的API名字。如果你定义的不一致，后期将很难维护。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6、API的参数一定要跟实际的保持一致，不能把实际可选参数定义成了必选参数，这种情况在请求时会直接被网关过滤掉。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;

</description>
        <pubDate>Sun, 09 Sep 2018 21:10:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/%E9%98%BF%E9%87%8CAPI%E7%BD%91%E5%85%B3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/%E9%98%BF%E9%87%8CAPI%E7%BD%91%E5%85%B3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid>
        
        <category>阿里</category>
        
        <category>API网关</category>
        
        <category>网关</category>
        
        <category>API</category>
        
        <category>GateWay</category>
        
        
      </item>
    
      <item>
        <title>CocoaPods使用备忘</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;使用CocoaPods也有很长一段时间了，最近几个月的时间里也主导了公司私有Pods的创建和使用。在此期间踩过了不少坑，在踩坑的过程中也收获了不少经验，更加熟练地掌握了CocoaPods的一些指令的使用。本篇作为这段时间收获的备忘。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一cocoapods简介&quot;&gt;一、CocoaPods简介&lt;/h2&gt;

&lt;p&gt;CocoaPods是专门为iOS工程提供第三方依赖库的管理工具，通过CocoaPods，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置，就可以直观、集中和自动化地管理我们项目的第三方库。&lt;/p&gt;

&lt;p&gt;CocoaPods将所有依赖的库都放在一个名为Pods的项目下，然后让主项目依赖Pods项目。然后，我们编码工作都从主项目转移到Pods项目。Pods项目最终会编译为一个libPod-项目名.a静态库，主项目依赖于这个静态库。&lt;/p&gt;

&lt;p&gt;对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;/p&gt;

&lt;p&gt;CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。&lt;/p&gt;

&lt;p&gt;CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： &lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/&quot;&gt;CocoaPods/CocoaPods&lt;/a&gt;, &lt;a href=&quot;https://github.com/CocoaPods/Core&quot;&gt;CocoaPods/Core&lt;/a&gt;, 和 &lt;a href=&quot;https://github.com/CocoaPods/Xcodeproj&quot;&gt;CocoaPods/Xcodeproj&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;cocoapod的核心组件&quot;&gt;CocoaPod的核心组件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CocoaPods/CocoaPod
这是是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CocoaPods/Core
Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Podfile
Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Podspec
.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CocoaPods/Xcodeproj
这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CocoaPod的安装和配置，以及Podfile中第三方库引用的语法规则（特别是版本号的语法格式）这里就不赘述了，下面挑重点讲一讲。&lt;/p&gt;

&lt;h2 id=&quot;二多target时podfile该如何写&quot;&gt;二、多target时Podfile该如何写？&lt;/h2&gt;

&lt;p&gt;我的建议是使用Ruby语法，定义不同的分组，然后不同的target可以自由选择依赖哪些分组，这种方式看起来更简洁，对于多target的项目来说也更友好：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform :ios, '8.0'

def commonPods #通用pods集
    pod 'AFNetworking', '~&amp;gt; 2.0'
    pod 'Masonry'
end

def appOnlyPods #app专用pods集
    pod 'MBProgressHUD'
end

def extensionPods #扩展专用pods集
    pod 'GTSDKExtension'
end

target :TestCocoaPods do
    commonPods
    appOnlyPods

    target :TestCocoaPodsTests do
    inherit! :search_paths
    # Pods for testing
    end

    target :TestCocoaPodsUITests do
        inherit! :search_paths
        # Pods for testing
    end
end

target :SecondTarget do
    commonPods
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;三如何忽略pods警告&quot;&gt;三、如何忽略Pods警告？&lt;/h2&gt;

&lt;p&gt;有些第三方Pod集成进来会有一大堆警告信息，如果你看着比较难受想把它忽略的话，在Podfile中对应的target或分组下加上关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;inhibit_all_warnings&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&quot;四如何直接引用第三方库中的头文件&quot;&gt;四、如何直接引用第三方库中的头文件？&lt;/h2&gt;

&lt;p&gt;在用CocoaPods集成第三方库之后，默认情况下，我们需要使用类似&lt;code class=&quot;highlighter-rouge&quot;&gt;#import &amp;lt;XXX/YYY.h&amp;gt;&lt;/code&gt;的方式引入第三方库的头文件。我们可以在Build Settings -&amp;gt; User Header Search Paths中添加&lt;code class=&quot;highlighter-rouge&quot;&gt;${SRCROOT}&lt;/code&gt;并设置成recursive，这样我们就可以直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;#impot &quot;YYY.h&quot;&lt;/code&gt;这种方式了。&lt;/p&gt;

&lt;h2 id=&quot;五pod-install-or-pod-update&quot;&gt;五、&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;如官方文档所说，&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;确实是大家最容易搞混的两条指令，很多人还没搞清楚这两条指令的区别，反正不管三七二十一上来就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;，大家一定要搞清楚这两条指令的区别。&lt;/p&gt;

&lt;p&gt;按照官方文档所说，&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;在第一次检索集成第三方以及每一次在Podfile中新增、更改或删除pod的时候使用。每一次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;命令，它都会下载安装新的pod，并且会把每一个安装的pod的版本信息写入Podfile.lock文件。Podfile.lock文件跟踪每一个安装的pod的版本并且上锁。每一次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;命令，只解决还没有在Podfile.lock中列出的依赖：对于已在Podfile.lock中列出的pod，会下载指定的版本，不会检查是否有新版本。对于没有在Podfile.lock中列出的pod，它会搜索并安装Podfile中指定的版本。&lt;/p&gt;

&lt;p&gt;直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;命令会检查安装Podfile中列出的所有pod的新版本（往往比较慢）。&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update PODNAME&lt;/code&gt;命令会检查PODNAME的新版本（不考虑Podfile.lock中记录的版本信息），它会把PODNAME更新为最新版本，只要跟Podfile中指定的版本匹配。也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update PODNAME&lt;/code&gt;将PODNAME更新到Podfile中指定的版本，可以是更新到老版本也可以是更新到新版本，取决于Podfile。（比如：如果此时Podfile中指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'AFNetworking', '~&amp;gt; 2.0'&lt;/code&gt;，此时执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update AFNetworking&lt;/code&gt;并不会把AFNetworking更新到最新版本（因为此时的版本满足大于等于2.0版），必须先修改Podfile中的版本信息才会更新到指定版本）。&lt;/p&gt;

&lt;p&gt;两者的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;命令来安装新的pod，每次在Podfile中新增和删除pod都使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Podfile中添加新的pod后应该用&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;命令，而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;命令。通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;命令安装新的pod而不用担心在同一进程中修改已有的pod。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;命令仅用在更新指定pod到指定版本或者更新所有pod。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的建议是：该用&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;的时候不要用&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update PODNAME&lt;/code&gt;。另外，尽量不要用&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;，因为它是全部检查一遍，不仅慢有时候还会出现坑。比如有一个依赖的第三方库本来是2.0版本的用的好好的，因为它是国外的资源，下载起来非常慢，我们在没有bug的情况下是不希望轻易去更新它的，那么如果你上来就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt;指令，OK， 如果你Podfile中指定了每次使用最新版本（不指定版本号），那么CocoaPods就会去下载最新的这个第三方库，那在下载完成之前你还要不要做其他事情了？这还是情况好的，如果这个最新的版本一直下载失败，所以一直集成失败怎么办？&lt;/p&gt;

&lt;h2 id=&quot;六如何创建私有pod&quot;&gt;六、如何创建私有Pod？&lt;/h2&gt;

&lt;p&gt;要创建私有Pod，首先我们需要两个私有仓库，一个放私有Pod源码，一个放私有Pod的说明书（类似公有Pod的&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot;&gt;CocoaPods/Specs&lt;/a&gt;）。&lt;/p&gt;

&lt;h3 id=&quot;1添加私有spec仓库到本地&quot;&gt;1、添加私有Spec仓库到本地&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo add privateSpecs your_privateSpecs.git

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果执行成功，之后便可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pod repo list&lt;/code&gt;命令查看本地Spec仓库列表，正常情况下会有一个公有的CocoaPod官方的master repo 和你的 privateSpecs repo，并可以看到它们在本地的存放路径（其实在&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.cocoapods/repos&lt;/code&gt;目录下）。&lt;/p&gt;

&lt;h3 id=&quot;2创建私有pod&quot;&gt;2、创建私有Pod&lt;/h3&gt;

&lt;p&gt;在私有Pod代码所在文件夹下执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod spec create your_podName&lt;/code&gt;在该目录下创建一个your_podName.podspec说明书文件。之后的工作就是编辑这个说明书文件了，这里简单注明一下规则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pod::Spec.new do |s|

  s.name         = &quot;ATCategory&quot;
  s.version      = &quot;0.0.1&quot;
  s.summary      = &quot;共用扩展类集合&quot;
  s.description  = &amp;lt;&amp;lt;-DESC
  大家如果需要用到扩展，都使用这里已有的扩展啦。
                   DESC
  s.homepage     = &quot;your_privatePodGit_address/ATCategory&quot;
  s.author       = { &quot;ApesTalk&quot; =&amp;gt; &quot;lqcjdx@163.com&quot; }
  s.platform     = :ios
  s.platform     = :ios, &quot;8.0&quot;
  s.source       = { :git =&amp;gt; &quot;your_privatePodGit_address&quot;, :tag =&amp;gt; &quot;#{s.version}&quot;
  # 如果你有多个私有Pod放在一个仓库里，你可以修改tag像下面这样，对应打tag的时候的规则就对应需要变成PodName-v0.0.1这样子了
  # s.source       = { :git =&amp;gt; &quot;your_privatePodGit_address&quot;, :tag =&amp;gt; s.name + &quot;-v&quot;+&quot;#{s.version}&quot;
}
  s.source_files  = 'ATCategory/**/*'
  s.public_header_files = 'ATCategory/Category/*.h'
  s.requires_arc = true
  s.frameworks = 'UIKit','Foundation'

# 依赖的系统library，这里是指系统的类似libz.tbd、libxml2.tbd这类的系统库
# s.library = 'z' // 单个
# s.libraries = 'z','xml2' // 多个

# 第三方.a
# s.vendored_libraries =
# 第三方frameworks文件
# s.vendored_frameworks =
# 依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency
# s.dependency 'AFNetworking', '~&amp;gt; 2.3'
# 资源文件地址
# s.resource_bundles = {
#   'ATCategory' =&amp;gt; ['ATCategory/Images/*.png']
# }
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3提交源代码并打tag&quot;&gt;3、提交源代码并打tag&lt;/h3&gt;

&lt;p&gt;注意这里tag必须跟podspec文件中的tag保持一致，因为CocoaPod是通过podspec文件中的tag去找源文件的，如果tag对应不起来就会验证失败。打好tag提交到远端。&lt;/p&gt;

&lt;h3 id=&quot;4验证podspec文件合法性和可选参数&quot;&gt;4、验证podspec文件合法性和可选参数&lt;/h3&gt;

&lt;p&gt;有两种验证方式，一种是本地验证&lt;code class=&quot;highlighter-rouge&quot;&gt;pod lib lint your_podName.podspec&lt;/code&gt;和联网验证&lt;code class=&quot;highlighter-rouge&quot;&gt;od spec lint your_podName.podspec&lt;/code&gt;。建议大家都用联网验证。&lt;/p&gt;

&lt;p&gt;这里可选参数有:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--allow-warnings&lt;/code&gt;：允许警告&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--sources=‘master,privateSpecs&lt;/code&gt;：指定源，比如你的私有pod同时依赖了公有库和私有库，你必须指定源才行，因为默认只会去在公有源中查找对应的依赖&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--use-libraries&lt;/code&gt;：如果使用了静态库，记得加上它&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5提交说明书文件到私有说明书库&quot;&gt;5、提交说明书文件到私有说明书库&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod repo push privateSpecs your_podName.podspec&lt;/code&gt;，同样的加上上面验证时使用到的可选参数。&lt;/p&gt;

&lt;h3 id=&quot;6如果使用素材&quot;&gt;6、如果使用素材？&lt;/h3&gt;

&lt;p&gt;官方建议pod中的素材用bundle的形式避免和主项目中的文件名发生冲突，那么集成后我们如何使用bundle中的素材呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSBundle *bundle = [NSBundle mainBundle];
//NSBundle *bundle = [NSBundle bundleForClass:[ClassFromPodspec class]];//对于静态库，拿到的是mainBundle，如果是动态库，拿到的是类所在的bundle。使用动态库需要在Podfile中开启use_frameworks!
NSURL *wttpodBundleURL = [bundle URLForResource:@&quot;WTTPod&quot; withExtension:@&quot;bundle&quot;];
NSBundle *wttpodBundle = [NSBundle bundleWithURL: wttpodBundleURL];
UIImage *img = [UIImage imageNamed:@&quot;Chat_checkin_empty_stu&quot; inBundle:wttpodBundle compatibleWithTraitCollection:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7关于subspec&quot;&gt;7、关于subspec&lt;/h3&gt;

&lt;p&gt;如果我们的pod中文件比较多，而我们又希望能像AFNetworking那样集成后分几个物理文件夹（默认会把所有文件都放在一个物理文件夹下，文件太多会显得很乱），那么就要用到subspec来把我们的pod分成几个独立的子模块。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
s.subspec '子模块名称' do |别名，不能和子模块名称相同，比如ss|

ss.source_files = ''

end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体怎么用，大家可以参考AFNetworking.podspec文件中的写法。&lt;/p&gt;

&lt;h2 id=&quot;七如何使用私有库&quot;&gt;七、如何使用私有库&lt;/h2&gt;

&lt;p&gt;如果我们同时使用了公有库和私有库，我们只需要在Podfile的头部同时把公有库和私有库的source加上即可。&lt;/p&gt;

&lt;h2 id=&quot;八pod-search搜不到私有库或者搜得到pod-install失败&quot;&gt;八、&lt;code class=&quot;highlighter-rouge&quot;&gt;pod search&lt;/code&gt;搜不到私有库？或者搜得到&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;失败？&lt;/h2&gt;

&lt;p&gt;在提交私有库说明书之后，先执行一下&lt;code class=&quot;highlighter-rouge&quot;&gt;pod repo update privateSpecs&lt;/code&gt;，然后再集成。&lt;/p&gt;

&lt;h2 id=&quot;九集成某一个pod速度过慢比如mobilevlckit总是下载失败&quot;&gt;九、集成某一个pod速度过慢，比如MobileVLCKit总是下载失败&lt;/h2&gt;

&lt;p&gt;把对应版本的MobileVLCKit下载下来放在访问速度更快的地方（比如内网服务器或者本机用Python开启一个FTP服务）在本机master repo源中搜索找到对应版本的MobileVLCKit.podspec.json文件，把其中的source改成我们存放MobileVLCKit.tar.xz文件地址，之后再执行相关指令集成。&lt;/p&gt;

&lt;p&gt;如何利用Python开启一个本地FTP服务：&lt;/p&gt;

&lt;p&gt;cd到要共享的目录下，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;python -m SimpleHTTPServer 8000&lt;/code&gt;，之后同一个局域网内就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;本机ip:8000&lt;/code&gt;访问到该共享文件夹了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&quot;http&quot;:&quot;http://192.168.210.111:8000/MobileVLCKit-3.1.2-bf58e19-37855b857a.tar.xz&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;获取本机IP地址的方法：按住Option的同时点下Mac菜单栏的无线网Icon，在下拉列表中即可看到IP地址。也可以在终端中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig en0&lt;/code&gt;命令查看。&lt;/p&gt;

&lt;h2 id=&quot;十验证podspec时报错-symbols-not-found-for-architecture-i386&quot;&gt;十、验证podspec时，报错 symbol(s) not found for architecture i386&lt;/h2&gt;

&lt;p&gt;检查一下是否私有Pod中使用到的什么文件不支持i386架构，比如什么.a文件。&lt;/p&gt;

&lt;p&gt;解决办法：在podspec文件中指定支持的架构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;valid_archs = ['armv7s','arm64',]
s.xcconfig = {
  'VALID_ARCHS' =&amp;gt;  valid_archs.join(' '),
}
s.pod_target_xcconfig = {
    'ARCHS[sdk=iphonesimulator*]' =&amp;gt; '$(ARCHS_STANDARD_64_BIT)'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;十一pod-init失败&quot;&gt;十一、&lt;code class=&quot;highlighter-rouge&quot;&gt;pod init&lt;/code&gt;失败？&lt;/h2&gt;

&lt;p&gt;用Xcode9.4.1新建一个项目，然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod init&lt;/code&gt;（Cocoapods1.4.0版本）时提示失败，错误提示如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
――― MARKDOWN TEMPLATE ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

### Command

/usr/local/Cellar/cocoapods/1.4.0/libexec/bin/pod init


### Report

* What did you do?

* What did you expect to happen?

* What happened instead?


### Stack

   CocoaPods : 1.4.0
        Ruby : ruby 2.3.3p222 (2016-11-21 revision 56859) [universal.x86_64-darwin17]
    RubyGems : 2.5.2
        Host : Mac OS X 10.13.3 (17D47)
       Xcode : 9.4.1 (9F2000)
         Git : git version 2.15.2 (Apple Git-101.1)
Ruby lib dir : /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib
Repositories : ios-cocoapodsSpecs - http://git.zhihuishu.com/coder/ios-cocoapodsSpecs.git @ 4c4f38416c28d58d4dda2a706879956c5861a55e
               master - https://github.com/CocoaPods/Specs.git @ 1eab292c36f39ecb104af54e474b00f142e57d0f


### Plugins


cocoapods-deintegrate : 1.0.2
cocoapods-plugins     : 1.0.0
cocoapods-search      : 1.0.0
cocoapods-stats       : 1.0.0
cocoapods-trunk       : 1.3.0
cocoapods-try         : 1.1.0


### Error


RuntimeError - [Xcodeproj] Unknown object version.
/usr/local/Cellar/cocoapods/1.4.0/libexec/gems/xcodeproj-1.5.4/lib/xcodeproj/project.rb:217:in `initialize_from_file'
/usr/local/Cellar/cocoapods/1.4.0/libexec/gems/xcodeproj-1.5.4/lib/xcodeproj/project.rb:102:in `open'
/usr/local/Cellar/cocoapods/1.4.0/libexec/gems/cocoapods-1.4.0/lib/cocoapods/command/init.rb:41:in `validate!'
/Library/Ruby/Gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:333:in `run'
/usr/local/Cellar/cocoapods/1.4.0/libexec/gems/cocoapods-1.4.0/lib/cocoapods/command.rb:52:in `run'
/usr/local/Cellar/cocoapods/1.4.0/libexec/gems/cocoapods-1.4.0/bin/pod:55:in `&amp;lt;top (required)&amp;gt;'
/usr/local/Cellar/cocoapods/1.4.0/libexec/bin/pod:22:in `load'
/usr/local/Cellar/cocoapods/1.4.0/libexec/bin/pod:22:in `&amp;lt;main&amp;gt;'


――― TEMPLATE END ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

[!] Oh no, an error occurred.

Search for existing GitHub issues similar to yours:
https://github.com/CocoaPods/CocoaPods/search?q=%5BXcodeproj%5D+Unknown+object+version.&amp;amp;type=Issues

If none exists, create a ticket, with the template displayed above, on:
https://github.com/CocoaPods/CocoaPods/issues/new

Be sure to first read the contributing guide for details on how to properly submit a ticket:
https://github.com/CocoaPods/CocoaPods/blob/master/CONTRIBUTING.md

Don't forget to anonymize any private data!

Looking for related issues on cocoapods/cocoapods...
 - Pod Update: RuntimeError - [Xcodeproj] Unknown object version. Xcode Beta 5
   https://github.com/CocoaPods/CocoaPods/issues/8003 [closed] [17 comments]
   a day ago

 - RuntimeError - [Xcodeproj] Unknown object version.
   https://github.com/CocoaPods/CocoaPods/issues/7697 [closed] [28 comments]
   3 weeks ago

 - Pod init. Unknown object version
   https://github.com/CocoaPods/CocoaPods/issues/7907 [closed] [2 comments]
   03 Jul 2018

and 42 more at:
https://github.com/cocoapods/cocoapods/search?q=[Xcodeproj]%20Unknown%20object%20version.&amp;amp;type=Issues&amp;amp;utf8=✓

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种失败原因是Cocoapods和xcodeproj版本兼容问题。&lt;/p&gt;

&lt;p&gt;尝试了网上的解决办法&lt;a href=&quot;https://link.jianshu.com/?t=https://github.com/CocoaPods/CocoaPods/issues/6168&quot;&gt;Run gem install xcodeproj:1.4.1&lt;/a&gt;，依然失败。&lt;/p&gt;

&lt;p&gt;解决办法：打开项目，在Project Document下将Project Format从Xcode 9.3-compatible修改为Xcode 8.0-compatible即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/Xocde_project_format.png&quot; alt=&quot;Xocde_project_format&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;十二在pod中引入项目文件报错file-not-found&quot;&gt;十二、在pod中引入项目文件报错（file not found）&lt;/h2&gt;

&lt;p&gt;在开发中有时候需要在pod中import项目中的文件进行调试或测试（当然这种情况比较少见），但是当你输入import的时候会发现系统根本没法联想到你想用的项目中的文件，即使你手动写入，也会报file not found的错误。&lt;/p&gt;

&lt;p&gt;此时，可以在我们的Pods项目中的Build settings下找到 User Header Search Paths，添加一行，并设置&lt;code class=&quot;highlighter-rouge&quot;&gt;$(SRCROOT)/..&lt;/code&gt;为recursive。注意有&lt;code class=&quot;highlighter-rouge&quot;&gt;/..&lt;/code&gt;，意思是到当前目录的上级目录。意思是在上级目录下递归查找文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;

</description>
        <pubDate>Wed, 22 Aug 2018 06:30:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/CocoaPods%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/CocoaPods%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</guid>
        
        <category>Xcode</category>
        
        <category>CocoaPods</category>
        
        <category>私有Pod</category>
        
        <category>Podfile</category>
        
        <category>pod-install</category>
        
        <category>pod-update</category>
        
        
      </item>
    
      <item>
        <title>博客搭建笔记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本篇记录一下自己是如何一步步利用GitHub Page、jekyll以及喵神的vno-jekyll模板来搭建属于自己的博客的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一在github上建一个usernamegithubio的仓库&quot;&gt;一、在GitHub上建一个username.github.io的仓库&lt;/h2&gt;

&lt;p&gt;注意username必须跟自己github用户名保持一致，包括大小写。然后你可以在仓库中新建一个index.html文件，简单写上点HTML代码，之后就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;https://username.github.io&lt;/code&gt;来访问自己的个人博客主页了。对，就是这么简单，其他一切GitHub都替你做好了。&lt;/p&gt;

&lt;p&gt;但是我不太想写HTML代码（主要是不太会写），更喜欢用人性化的Markdown来写文章。所以，我需要利用jekyll这个利器来帮我。对于不熟悉jekyll和HTML的朋友来说，搭建自己的博客主题也是比较麻烦的事情，我们可以借助开源的一些比较好的主题，把这一步也简化掉，剩下的就是我们好好写博客啦。&lt;/p&gt;

&lt;h2 id=&quot;二下载喵神的vno-jekyll主题&quot;&gt;二、下载喵神的vno-jekyll主题&lt;/h2&gt;

&lt;p&gt;克隆自己的GitHub Page仓库到本地目录，然后下载&lt;a href=&quot;https://github.com/onevcat/vno-jekyll&quot;&gt;vno-jekyll&lt;/a&gt;解压文件到该目录下。再次感谢喵神提供好看的模板 Thanks♪(･ω･)ﾉ。&lt;/p&gt;

&lt;h2 id=&quot;三安装jekyll&quot;&gt;三、安装jekyll&lt;/h2&gt;

&lt;p&gt;详细介绍请看&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll中文网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以下是安装jekyll的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll
jekyll new ApesTalk
cd ApesTalk
bundle install
bunde exec jekyll server
//browse to http://localhost:4000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四修改_configyml文件&quot;&gt;四、修改_config.yml文件&lt;/h2&gt;

&lt;p&gt;阅读_config.yml文件，并将其修改成你期望的样式。&lt;/p&gt;

&lt;h2 id=&quot;五预览&quot;&gt;五、预览&lt;/h2&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;bunlde exec jekyll server&lt;/code&gt;命令来把服务跑起来，然后你就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;htpp://localhost:4000&lt;/code&gt;这个地址来预览你的博客了。如果对此次修改不满意，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;control+C&lt;/code&gt;来停止服务的运行，再次修改相关文件，之后再重新运行服务并预览效果，直到修改的自己满意为止。&lt;/p&gt;

&lt;h2 id=&quot;六问题备注&quot;&gt;六、问题备注&lt;/h2&gt;

&lt;p&gt;1、要修改博客主页的样式（比如按钮个数、蒙层颜色）？&lt;/p&gt;

&lt;p&gt;需要修改_config.yml文件。&lt;/p&gt;

&lt;p&gt;2、修改文件日期？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt;文件夹下的文件不仅要修改文件名中日期，还要修改文件头部中的date字段。&lt;/p&gt;

&lt;p&gt;3、修改背景图和头像？&lt;/p&gt;

&lt;p&gt;在assets文件夹下替换相关素材即可，如果后缀名发生了改变，你还需要修改_site/index.html文件中对图片素材的引用处。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://apestalk.github.io/assets/BlogImages/wx.jpeg&quot; alt=&quot;欢迎关注支持&quot; /&gt;&lt;/p&gt;
&lt;center&gt;感谢关注支持&lt;/center&gt;
</description>
        <pubDate>Mon, 20 Aug 2018 00:40:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</guid>
        
        <category>GitHub</category>
        
        <category>jekyll</category>
        
        <category>vno-jekyll</category>
        
        
      </item>
    
  </channel>
</rss>
